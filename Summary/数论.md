# 欧拉函数

## 欧拉函数定义

通常用 $φ(n)$ 表示 $n$ 的欧拉函数，$φ(n)$ 为1~n 中和 $n$ 互质的数的个数。

## 欧拉函数公式

用 $p_i$ 表示 $n$ 的第 $i$ 个质因子，则 $φ(n)=n(1-\frac 1 {p_1})(1-\frac 1 {p_2})(1-\frac 1 {p_3})···(1-\frac 1 {p_k})$.

这个公式可以从两个方面来证明，大家可以选择一种自己理解起来比较容易的方式。

### 证明1（容斥原理角度）

1~n 中有 $n$ 个数，我们可以用 $n$ 减去 1~n 中和 $n$ 不互质的数，就是欧拉函数的值。

1~n 中 $p_i$ 的倍数有 $\frac n {p_i}$ 个数，他们都和 $n$ 不互质，而其他的数都和 $n$ 互质（因为没有公共质因子）。

首先可以得到这样一个式子 
$$
n - \frac n {p_1}- \frac n {p_2}- \frac n {p_3}-···- \frac n {p_k}
$$
但是这个并不是欧拉 函数的值，因为所有的 $p_ip_j$ 的倍数都会被当作$p_i$ 的倍数减掉一次，也会被当作 $p_j$ 的倍数减掉一次，这样子他们就被减掉了两次，但是本来只应该减掉一次的，所以我们就要再加上所有 $p_ip_j$ 倍数的个数，即 
$$
n - \frac n {p_1}- \frac n {p_2}- \frac n {p_3}-···- \frac n {p_k}\\
+\frac n {p_1p_2}+\frac n {p_1p_3}+\frac n {p_2p_3}+···+\frac n {p_jp_k}
$$
同样，这个式子也不是欧拉函数，因为所有的  $p_ip_jp_k$ 的倍数会被 $p_i,\ p_j,\ p_k$分别减一次，又会被 $p_ip_j,\ p_ip_k,\ p_jp_k$ 分别加一次，总体没加没减，但应该被减去一次的，所以我们要再减去所有 $p_ip_jp_k$ 的倍数的个数，即
$$
n - \frac n {p_1}- \frac n {p_2}- \frac n {p_3}-···- \frac n {p_k}\\
+\frac n {p_1p_2}+\frac n {p_1p_3}+\frac n {p_2p_3}+···+\frac n {p_jp_k}\\
-\frac n {p_1p_2p_3}-\frac n {p_1p_2p_4}-···-\frac n {p_ip_jp_k} 
$$
可以发现所有的质因子个数为奇数的项都是负的，所有质因子个数为偶数的项都是正的将欧拉函数的表达式展开后的得到的就是这一串式子。 

### 证明2（概率角度）

用 $P$ 表示从 1~n 中选一个数，和 n 互质的概率， $P=\frac {φ(n)} n$ 即 $φ(n)=n*P$.

现在从另一个角度来求 $P$，从 1~n 中任选一个数 $x$ ，$x$ 是 $p_i$ 的倍数的概率为 $\frac {\frac n {p_i}} n$, 即 $\frac 1 {p_i}$. $x$ 不是 $p_i$ 的倍数的概率为$1 - \frac 1 {p_i}$. 若 $x$ 与 n 互质，则 $x$ 不能是任意一个 $p_i$ 的倍数，即 $P=(1-\frac 1 {p_1})(1-\frac 1 {p_2})(1-\frac 1 {p_3})···(1-\frac 1 {p_k})$. 这样子我们就得到了欧拉函数的值。

## 求欧拉函数

### 公式法求欧拉函数

- 这个算法通常用于求单个数的欧拉函数，复杂度为$O(\sqrt n)$。思路类似与分解质因数，再分解质因数的过程中，将质因子带入欧拉函数的公式即可。
- 代码：

```c++
int phi(int n) {
    int res = n;
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0)
            res = res / i * (i - 1);	// 这里需要先除再乘，防止爆int
        while (n % i == 0) n /= i;
    }
    if (n > 1) res = res / n * (n - 1);	// 大于根号n的质因子
    return res;
}
```

### 筛法求欧拉函数

- 这个算法通常用于求一个区间内，每个数的欧拉函数，可以在 $O(n)$ 的时间内，求出 1~n 中每个数的欧拉函数。代码是在线性筛的基础上做了些更改。线性筛大致可以分为两部分，第一部分判断每个数是不是质数，第二部分从小到大枚举所有的质数，筛掉`primes[j] *  i`，如果`i % primes[j] == 0`则跳出循环。筛法求欧拉函数也是建立在这个基础上，下面我们来分类讨论下(我们用$p_j$表示`primes[j]`)：

   1. 首先如果 n 是一个质数，则从 n~(n - 1) 中的每一个数都与 n 互质，即 $φ(n) = n - 1$。

    2. 如果 n 不是质数，则 n 一定会被某个 $p_j*i$筛掉，即一定会有某一轮循环$n=p_j*i$，设 $i$ 的质因子为$p_1,p_2,p_3···p_k$

   	1. 如果被筛掉的时候$i\%p_j=0$，根据线性筛，$p_j$是 $i$ 的最小质因子，n 的质因子的个数与 $i$ 一致。
   		$$
   		φ(n)=p_j*i*(1-\frac 1 {p_1})(1-\frac 1 {p_2})···(1-\frac 1 {p_k})=φ(i)*p_j
   		$$

   	2. 如果被筛掉的时候$i \% p_j\neq0$，根据线性筛，$p_j$小于 $i$ 的最小质因子，$n$ 的质因子比 $i$ 的质因子多出一个 $p_j$。
   		$$
   		φ(n)=p_j*i*(1-\frac 1 {p_1})(1-\frac 1 {p_2})···(1-\frac 1 {p_k})(1- \frac 1 {p_j})=φ(i)*(p_j-1)
   		$$
   		

- 代码：

```c++
bool st[N];
int primes[N], phi[N];
void euler(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
            phi[i] = i - 1;		// i是质数
        }
        for (int j = 0; primes[j] <= n / i; j++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0){
                phi[primes[j] * i] = phi[i] * primes[j];  	// primes[j]是i的最小质因子
                break;
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);	// primes[j]小于i的最小质因子
        }
    }
}
```

### 例题

在一个平面直角坐标系的第一象限内，如果一个点 $(x,y)$ 与原点 $(0,0)$ 的连线中没有通过其他任何点，则称该点在原点处是可见的。

例如，点 $(4,2)$ 就是不可见的，因为它与原点的连线会通过点 $(2,1)$。

部分可见点与原点的连线如下图所示：

![3090_1.png](https://www.acwing.com/media/article/image/2019/01/18/19_a68c1a281a-3090_1.png)

编写一个程序，计算给定整数 $N$ 的情况下，满足 $0≤x,y≤N$的可见点 $(x,y)$ 的数量（可见点不包括原点）。

#### 输入格式

第一行包含整数 $C$，表示共有 $C$ 组测试数据。

每组测试数据占一行，包含一个整数 $N$。

#### 输出格式

每组测试数据的输出占据一行。

应包括：测试数据的编号（从 $1$ 开始），该组测试数据对应的 $N$ 以及可见点的数量。

同行数据之间用空格隔开。

#### 数据范围

$1≤N,C≤1000$

#### 输入样例：

```
4
2
4
5
231
```

#### 输出样例：

```
1 2 5
2 4 13
3 5 21
4 231 32549
```



#### 思路

首先通过观察可以发现，在$x=0,y=0,y=x$这三条线上，可见的点只有$(0,1),(1,0),(1,1)$这三个点，其它的可见的点沿着$y=x$这条线是对称的，所以我们只需要求出一边然后乘$2$即可。所有可见的点都满足$\gcd(x,y)=1$，因为如果$\gcd(x,y)\neq 1$，那么给$x,y$分别除以最大公约数，得到的新点一定在这个点之前，且斜率相同，那么这个点一定不可见。现在问题就转换为了求所有满足$\gcd(x,y)=1$的点对数。可以先求出下面的然后乘$2$，对于每一个$x$，满足条件的$y$的数目应该为$φ(x)$，那么最终的答案就应该为$3+\sum_{i=2}^nφ(i)$。



#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 1010;

bool st[N];
int primes[N], phi[N], cnt;
void euler(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0){
                phi[primes[j] * i] = phi[i] * primes[j];
                break;
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
}

int main() {
    int t;
    cin >> t;
    euler(1000);
    for (int i = 1; i <= t; i++) {
        int n;
        cin >> n;
        int res = 0;
        for (int i = 2; i <= n; i++)
            res += phi[i];
        cout << i << ' ' << n << ' ' << 3 + 2 * res << endl;
    }
    return 0;
}
```



## 欧拉定理与费马小定理

- 欧拉定理：若 a 与 n 互质，则$a^{φ(n)}\equiv1\pmod n$即$a^{φ(n)}\%n=1$。

- 费马小定理：若a 与 p 互质，且 p 为质数，则$a^{p-1}\equiv1\pmod p$。其实就是欧拉定理 n 为质数的一种特殊情况，**这个定理非常重要**，用的要比欧拉定理多。



下面我们来证明下欧拉定理：

设$x_1,x_2···x_{φ(n)}$是1~n中与 n 互质的数，这$φ(n)$个数模 n 两两不同，且余数与 n 互质。然后可以发现$ax_1,ax_2···ax_{φ(n)}$也有上述的性质，下面我们证明下这两条性质：
 	
1. 模 n 两两不同：用反证法，若$ax_i\equiv ax_j \pmod n$，则$a(x_i-x_j) \equiv 0 \pmod n$，因为$x_i-x_j$一定不是 n 的倍数，所以只有 a 为 n 的倍数时，上式满足，这时会与欧拉函数的条件矛盾。
1. 模 n 余数与 n 互质：这个证明比较容易，因为 a 与 n 互质，$x_i$与 n 互质，所以$ax_i$也一定与 n 互质。

​		继续证明欧拉定理，现在我们证明了$ax_1,ax_2···ax_{φ(n)}$模 n 后是 n 个不同的数，且都与 n 互质。而 1~n 中与 n 互质的数一共只有$φ(n)$个，所以$ax_1,ax_2···ax_{φ(n)}$与$x_1,x_2···x_{φ(n)}$模 n 后是同一组数，所以就有$a^{φ(n)}x_1x_2···x_{φ(n)} \equiv x_1x_2···x_{φ(n)}\pmod n$即$a^{φ(n)}\equiv 1\pmod n$。



# 扩展欧几里得算法

- 算法的推导

先来看一个方程
$$
ax+by=\gcd(a,b) &(1)\\
$$


扩展欧几里得算法用于求解上述的一组整数解。需要注意两点，第一我们求得是这个方程得整数解，第二这个方程有无数组解，我们求的只是它得一组解。这个算法是在欧几里得算法的基础上进行了一些扩展，下面我们进行下推到，思路是通过欧几里得算法来缩小系数得范围，直到递归边界，这时候我们可以直接给出方程的一组解。

我们将$(1)$式中得$a,b$分别换为$b,a\%b$可得
$$
bx'+(a\%b)y'=\gcd(b,a\%b)&(2)\\
$$
根据欧几里得算法$\gcd(a,b)=\gcd(b,a\%b)$，我们可以将上面两个式子合并为
$$
ax+by=bx'+(a\%b)y'
$$
又因为$a\%b=a-b*\lfloor\frac a b\rfloor$，代入上式得
$$
ax+by=bx'+(a-b*\lfloor\frac a b\rfloor)y'
$$
将$a,b$分离得
$$
ax+by=ay'+b(x'-\lfloor\frac a b\rfloor y')
$$
现在我们就得到了$x,y与x',y'$得对应关系即
$$
\left\{
\begin{array}{lr} 
	x=y'\\
	y=x'-\lfloor\frac a b\rfloor y'
\end{array}

\right.
$$
上面左边得$x,y$是方程$(1)$的解，右边得$x',y'$是方程$(2)$的解，现在我们建立起了两个方程解的对应关系。然后我们就可以通过欧几里得算法迭代，来缩小$a,b$的值。当达到递归边界，即$b=0$的时候，方程会变成这个样子
$$
ax+0*y=\gcd(a,0)
$$
显然$x=1,y=0$是它的一组合法解，然后再通过我们得到得方程解得对应关系，逐步回溯就可以得到原方程得一组合法解。

- 代码：

```c++
int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, x, y);
    int tmp = y;
    y = x - (a / b) * y;
    x = tmp;
    return d;
}
```



# 一次不定方程

来看一个方程
$$
ax+by=m&(3)\\
$$


我们称这样子的方程为一次不定方程，其实就是将上面$(1)$式的右的$gcd(a,b)$换为了任意整数$m$，下面我们来仔细讨论下这个方程。

## 一次不定方程有解的充要条件

- 结论：一次不定方程有解的充要条件为$\gcd(a,b)\ |\ m$.

- 证明：

	1. 充分性：

		设方程$(1)$的一组解为$x_0,y_0$，令$d=gcd(a,b)$则有
		$$
		ax_0+by_0=d
		$$
		在方程两边同乘$m/d$得
		$$
		ax_0*\frac m d+by_0*\frac m d=m
		$$
		这样子就得到了方程$(3)$的一组特解
		$$
		\left\{
		\begin{array}{lr} 
			x=x_0*\frac m d\\
			y=y_0*\frac m d
		\end{array}
		
		\right.
		$$
		
2. 必要性：
	
	因为$a,b$都是$d$的整数倍，所以它们的线性组合也一定是$d$的倍数，所以若$m$不是$d$的倍数，方程一定无解。

## 一次不定方程的通解

### 方程(1)的通解

- 结论：

设方程$(1)$的一组特解为$x_0,y_0$，$d=\gcd(a,b)$，$t$为任意整数，则方程$(1)$的通解为：
$$
\left\{
\begin{array}{lr} 
	x=x_0+\frac b d*t\\
	y=y_0-\frac a d*t
\end{array}

\right.
$$

- 证明：

1. 先证明所有这个形式的$x,y$都是方程$(1)$的解，将$x,y$代入$ax+by=d$得
	$$
	a(x_0+\frac b d*t)+b(y_0-\frac a d*t)=d
	$$
	展开得
	$$
	ax_0+a*\frac b d*t+by_0-a*\frac b d*t=d
	$$
	即
	$$
	ax_0+by_0=d
	$$
	显然成立，所以所有得上述形式得$s,y$都是方程$(1)$的解。

2. 然后证明方程$(1)$的所有解都可以表示成上述的形式
	$$
	\left\{
	\begin{array}{lr} 
		ax+by=d\\
		ax_0+by_0=d
	\end{array}
	
	\right.
	$$
	联立得
	$$
	a(x-x_0)=-b(y-y_0)
	$$
	方程两边同时除以$d$得
	$$
	\frac a d(x-x_0)=-\frac b d(y-y_0)
	$$
	因为$d=\gcd(a,b)$，所以$\frac a d$与$\frac b d$互质，又因为$y-y_0$是整数，所以$\frac a d(x-x_0)$是$\frac b d$的整数倍，所以$x-x_0$一定是$\frac b d$的整数倍。即$\frac b d | x-x_0$，通过简单的变形可以写成$x=x_0+\frac b d*t$，同理$y=y_0-\frac a d*t$。

### 方程(3)的通解

- 结论：

$$
\left\{
\begin{array}{lr} 
	x=x_0*\frac c d+\frac b d*t\\
	y=y_0*\frac c d-\frac a d*t
\end{array}

\right.
$$

其实就是将特解做一下替换，其他的与方程$(1)$一样，证明过程与上面的证明思路一样，这里就不证明了，感兴趣的可以自己证明下。

## 例题

### 题目描述

给定 $n$ 组数据 $a_i,b_i,m_i$，对于每组数求出一个 $x_i$，使其满足 $a_i*x_i\equiv b_i\pmod {m_i}$，如果无解则输出 `impossible`。

#### 输入格式

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一组数据 $a_i,b_i,m_i$。

#### 输出格式

输出共 $n$ 行，每组数据输出一个整数表示一个满足条件的 $x_i$，如果无解则输出 `impossible`。

每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。

输出答案必须在 $int$ 范围之内。

#### 数据范围

$1≤n≤10^5$,
$1≤a_i,b_i,m_i≤2×10^9$

#### 输入样例：

```
2
2 3 6
4 3 5
```

#### 输出样例：

```
impossible
-3
```



### 思路

将$a_i*x_i\equiv b_i\pmod {m_i}$进行下简单的变形，可以变为$a_i*x_i+m_i*y_i=b_i$，可以先用扩展欧几里得算法求出$a_i*x_i+m_i*y_i=\gcd(a_i,m_i)$的一组解$x_0,y_0$，和$a,b$的最大公约数$d$，然后判断$b_i$是否为$d$的倍数，如果不是，则方程无解，否则方程的一组解为$x_0*\frac {b_i} d,y_0*\frac {a_i} d$，题目要求答案的范围在$int$范围内，我们将求得的解模$m_i$即可。

### 代码

```c++
#include <iostream>

using namespace std;

int exgcd(int a, int b, int &x, int &y){
    if(b == 0){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, x, y);
    int tmp = y;
    y = x - (a / b) * y;
    x = tmp;
    return d;
}

int main(){
    int n, a, b, m, x, y;
    cin >> n;
    while(n--){
        cin >> a >> b >> m;
        int d = exgcd(a, m, x, y);
        if(b % d != 0) {
            puts("impossible");
            continue;
        }
        x = 1ll * x * b / d % m;
        cout << x << endl;
    }
    return 0;
}
```



# 逆元

## 逆元的定义

如果$ax\equiv 1\pmod p$，则称$a$关于模$p$的乘法逆元为$x$，简称为$a$的逆元，通常用$a^{-1}$表示$a$的逆元。

那么逆元有什么用呢？我们知道加、减、乘都满足模运算恒等式，即
$$
(a+b)\%p=(a\%p+b\%p)\%p\\
(a-b)\%p=(a\%p-b\%p)\%p\\
(a*b)\%p=(a\%p*b\%p)\%p
$$
但是$\frac a b\%p$不一定等于$\frac {a\%p} {b\%p}$，引入逆元后，这个问题就得到了很好的解决，即
$$
\frac a b\%p=ab^{-1}\%p
$$
根据逆元的定义$bb^{-1}\%p = 1$，上面的式子是显然成立的。

## 逆元存在的充要条件

- 结论：逆元存在的充要条件为$\gcd(a,p)=1$，即$a$与$p$互质。
- 证明：$ax \equiv 1 \pmod p$又可以写为$ax+py=1$，逆元存在等价于这个一次不定方程有解，显然条件为$\gcd(a,p)=1$.

## 求逆元

1. 模数$p$为质数：

	这种情况，我们通常用费马小定理求解，根据费马小定理，若$a,p$互质，且$p$为质数，则有$a^{p-1}\equiv1\pmod p$，即$a*a^{p-2}\equiv1\pmod p$。这种情况下$a^{-1}=a^{p-2}$，使用快速幂求解即可。

2. 模数p不为质数：

	这种情况下，用欧几里得算法求解$ax+py=1$，得到的$x$即为$a$的逆元。


## 例题

### 题目描述

#### 题目描述

有一只甲壳虫想要爬上一颗高度为$n$ 的树，它一开始位于树根，高度为$0$。
当它尝试从高度 $i-1$ 爬到高度为$i$ 的位置时有 $Pi$ 的概率会掉回树根。
求它从树根爬到树顶时，经过的时间的期望值是多少。

#### 输入格式

输入第一行包含一个整数 $n$ 表示树的高度。
接下来 $n$ 行每行包含两个整数$x_i, y_i$，用一个空格分隔，表示$P_i = \frac {x_i} {y_i}$。
$1≤n≤100000,1≤x_i<y_i≤10^9$。

#### 输出格式

输出一行包含一个整数表示答案，答案是一个有理数，请输出答案对质数 998244353 取模的结果。
其中有理数 $\frac a b$ 对质数 $P$ 取模的结果是整数 $c$ 满足$0 ≤ c < P$ 且$c · b \equiv a \pmod P$。

#### 输入样例1

```
1
1 2
```

#### 输出样例1

```
2
```

#### 输入样例2

```
3
1 2
3 5
7 11
```

#### 输出样例2

```
623902744
```



### 思路

这个题是今年蓝桥杯的一道题，题目用到的是期望$dp$和逆元，下面我们来分析下。

我们用$t_i$表示爬到高度为$i$的期望时间，$t_i$怎么计算呢？可以这样子考虑，如果不考虑掉回树根的话，那么显然有
$$
t_i=t_{i-1}+1
$$
这个时间不管掉不掉回树根都是要算的。然后我们考虑掉回树根的情况，如果掉回树根的话，那么需要额外花费的时间为爬到$i$的期望时间$t_i$，合起来则有
$$
t_i=t_{i-1}+1+\frac {x_i} {y_i}t_i
$$
即
$$
t_i=(t_{i-1}+1)*\frac {y_i} {y_i-x_i}
$$


题目要求我们讲结果对$P$取模，它后面说的那句话其实就是求一个逆元 **(**根据逆元的定义$\frac a b\%p=ab^{-1}\%p$**)** .对我们得到的递推式两边同时模$P$得
$$
t_i \equiv (t_i+1)*y_i*(y_i-x_i)^{-1} \pmod P
$$
然后根据这个递推式我们就可以求出每一个$t_i\%P$后的值。

### 代码

```c++
#include <iostream>

using namespace std;

const int mod = 998244353;

typedef long long ll;

ll pow(ll a, ll b, ll p) {
    ll c = 1 % p;
    while (b) {
        if (b & 1)
            c = c * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return c;
}

int main() {
    int n;
    ll t = 0;
    int x, y;
    cin >> n;
    while (n--) {
        cin >> x >> y;
        // 为了防止三个数乘起来爆 long long 需要边乘边模
        t = (t + 1) * y % mod * pow(y - x, mod - 2, mod) % mod;
    }
    cout << t << endl;
    return 0;
}
```





