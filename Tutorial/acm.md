# Optimal Partition

- 题目链接: [Problem - 1667B - Codeforces](https://codeforces.com/problemset/problem/1667/B).
- 代码: cf#783v2D.cpp
- 解决方法: 离散化+线段树优化dp

## 题意

- 题目描述：

	给定一个长为n的数组a，定义某一数组的价值为：

	1. 数组长度，当数组元素和大于0时

	2. 0，当数组元素和等于0时

	3. 负的数组长度，当数组元素和小于0时

​		将给定数组划分成若干个连续的数组，求可获得的最大价值。

- 数据范围$n <= 5*10^5, -10^9<=a[i]<=10^9$

## 思路

1. 首先可以比较容易的想到使用dp来解决问题，定义dp[i]表示数组前i位可以获得的最大价值，用$v(i,j)$表示数组第i位到第j位的价值，s[i]表示前i位的前缀和，则：$dp[i] = \max\limits_{0<j< i}(dp[j] + v(j+1,i))$，$v(i,j)$可以通过预处理前缀和数组后$O(1)$得到，而dp求解过程需要先枚举一下每一个位置，在每次状态转移的时候需要枚举之前的每一个位置来求最优解，总复杂度为$O(n^2)$，无法通过。

2. 考虑对算法进行优化，整个算法过程中有两次循环，第一重循环时枚举每一个位置，不可以省略，考虑可不可以将状态转移的复杂度降低。先将状态转移方程展开观察下
	$$
	dp[i]=\left\{
		\begin{array}{lr} 
		dp[j]+i-j, & s[i]>s[j] \\
		dp[j], & s[i]=s[j] \\
		dp[j]+j-i, & s[i]<s[j] 
		\end{array}
	\right.
	$$
	可以发现dp[i]和dp[j]-j, dp[j], dp[j]+j有关系，以第一种情况为例，每次更新dp[i]时，即查询前i-1个位置上前缀和小于s[i]的dp[j]-j的最大值，区间查询最值可以使用线段树来完成，我们在s[i]的值域上建立三颗线段树，分别动态维护dp[j]-j, dp[j], dp[j]+j的最大值，每次状态转移时根据s[i]查询最值，之后在线段树中s[i]更新的位置上更新即可。这样既可以保证每次查询时线段树中维护的时前i-1个位置上的信息。

3. 最后还有一个小的问题，s[i]的数据范围会很大，我们无法直接在值域上建立线段树，需要先对s数组离散化，然后再建立线段树。

