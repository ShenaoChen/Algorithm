# 中等题目

## 911.在线选举

- 题目链接: https://leetcode-cn.com/problems/online-election/

该题目可以使用哈希表加二分搜索来实现，用一个哈希表来存储每一个人的选票数，记录选票最多的人的下标。预处理过程遍历 persons 数组，每次将当前选票最多的人的下标存入到tops数组中。则tops[i]代表，第 i 票投出后，第 i + 1 票投出前选票最多的人的下标。然后对于 q 函数，只需要二分找到离 t 最近且不大于t的数的下标 pos，即 t 时刻投出的最后一票的下标，然后直接返回tops[pos]即可.
## 523. 连续的子数组和 

- 题目链接: https://leetcode-cn.com/problems/continuous-subarray-sum/

### 暴力解法
枚举所有的区间，分别对这些区间求和判断。枚举所有的区间复杂度为 O(n^2)，计算每一个区间的和复杂度为 O(n)，整体复杂度为 O(n^3)，数据范围为 1e5，肯定超时。
### 前缀和优化
思路为先预处理nums数组的前缀和，复杂度为 O(n)，然后枚举所有的区间，对于每一个区间可以通过前缀和数组 O(1) 的时间内计算出子区间的和，总体复杂度优化到了 O(n^2)，但由于数据量较大，复杂度还是不能接受。
### 前缀和+同余定理+哈希表
前缀和优化后的算法的主要时间花费在了枚举所有的子区间这一步，需要将这一步优化掉。我们判断每一个子区间的依据是子区间的和是否为 k 的倍数，并且该区间的长度是否大于2，而[i + 1, j]子区间的和又可以根据前缀和写为 sum[j] - sum[i] ，区间长度为 j - i。即判断是否 k | (sum[j] - sum[i])，根据同余定理，k | (a - b) 等价于 a，b模k同余，所以就可以将问题转化为求每一个前缀模k的余数，并判断余数相等的前缀组成的子区间长度是否大于等于2。可以用哈希表来存储每一个余数第一次出现的下标，当余数再次出现时就判断组成的子区间长度是否大于等于2。

## 807. 保持城市天际线 

- 题目链接: https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/

`grid[i][j]` 可以更改当且仅当 `grid[i][j]`不为第i行的最大值，也不为第j列的最大值。可以用两个数组r, c分别来存储每一行和每一列的最大值，对矩阵进行一次遍历即可求得。然后再遍历一次矩阵，当`grid[i][j] `满足上述条件时，就给答案加`min(r[i], c[j]) - grid[i][j]`.

## 846. 一手顺子 

- 题目链接: https://leetcode-cn.com/problems/hand-of-straights/

1. 只有当牌的数量是groupSize的倍数时，才有可能实现分组，当不满足该条件是可以直接返回false。
2. 对于满足上述条件的情况，我们可以采用排序+哈希表的方法来实现。具体步骤为：
   1. 将数组排序，然后统计数组中的每一个数出现的次数，讲结果存入到哈希表中。
   2. 遍历排序好的数组，每次判断当前这个数c是否在哈希表中，如果不在，则说明已经被抽走，判断下一个；否则依次判断c, c + 1, c + 2, ... c + groupSize - 1是否在哈希表中，如果不在，则不能分组，返回false，否则讲哈希表中记录的数量减一。
3. 如果遍历完了整个数组则返回true。

## 11. 盛最多水的容器 

- 题目链接: https://leetcode-cn.com/problems/container-with-most-water/

该题目为一道经典的双指针题目，整体思路为初始化时将左右指针分别指向数组头和数组尾，每次判断当前构成的面积是否更新了最大值，每次更新指针的值时将数值较小的指针向另一个指针的方向移动（移动较大的指针并不会使当前的最大值发生改变），最后当左指针和右指针重合的时候即可确定最大值。

# 困难题目

## 剑指 Offer 51. 数组中的逆序对 

- 题目链接: https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/

### 暴力解法
可以使用两重循环遍历数组来求得答案。i从0到n-1，j从0到i，当a[i] < a[j]时，给答案加1。思路简单，但是复杂度高，会超时。
### 归并排序
根据归并排序的特点，在归并排序递归的回归过程中，要合并的左右数组已经排序好。用i遍历左数组，j遍历右数组，当a[i] > a[j]时，说明从i到mid的数组元素都大于a[j]，产生的逆序数为mid - i + 1。可以使用归并排序，在每次合并数组的时候，进行一次上述判断，并更新答案。
